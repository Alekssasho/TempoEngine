// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GEOMETRYDATABASE_TEMPEST_DEFINITION_H_
#define FLATBUFFERS_GENERATED_GEOMETRYDATABASE_TEMPEST_DEFINITION_H_

#include "flatbuffers/flatbuffers.h"

namespace Tempest {
namespace Definition {

struct MeshMapping;
struct MeshMappingBuilder;

struct GeometryDatabase;
struct GeometryDatabaseBuilder;

struct MeshMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_VERTEX_OFFSET = 6,
    VT_VERTEX_COUNT = 8
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool KeyCompareLessThan(const MeshMapping *o) const {
    return index() < o->index();
  }
  int KeyCompareWithValue(uint32_t val) const {
    return static_cast<int>(index() > val) - static_cast<int>(index() < val);
  }
  uint32_t vertex_offset() const {
    return GetField<uint32_t>(VT_VERTEX_OFFSET, 0);
  }
  uint32_t vertex_count() const {
    return GetField<uint32_t>(VT_VERTEX_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_VERTEX_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_VERTEX_COUNT) &&
           verifier.EndTable();
  }
};

struct MeshMappingBuilder {
  typedef MeshMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(MeshMapping::VT_INDEX, index, 0);
  }
  void add_vertex_offset(uint32_t vertex_offset) {
    fbb_.AddElement<uint32_t>(MeshMapping::VT_VERTEX_OFFSET, vertex_offset, 0);
  }
  void add_vertex_count(uint32_t vertex_count) {
    fbb_.AddElement<uint32_t>(MeshMapping::VT_VERTEX_COUNT, vertex_count, 0);
  }
  explicit MeshMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeshMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshMapping> CreateMeshMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    uint32_t vertex_offset = 0,
    uint32_t vertex_count = 0) {
  MeshMappingBuilder builder_(_fbb);
  builder_.add_vertex_count(vertex_count);
  builder_.add_vertex_offset(vertex_offset);
  builder_.add_index(index);
  return builder_.Finish();
}

struct GeometryDatabase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDatabaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTEX_BUFFER = 4,
    VT_MAPPINGS = 6
  };
  const flatbuffers::Vector<uint8_t> *vertex_buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VERTEX_BUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tempest::Definition::MeshMapping>> *mappings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tempest::Definition::MeshMapping>> *>(VT_MAPPINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTEX_BUFFER) &&
           verifier.VerifyVector(vertex_buffer()) &&
           VerifyOffset(verifier, VT_MAPPINGS) &&
           verifier.VerifyVector(mappings()) &&
           verifier.VerifyVectorOfTables(mappings()) &&
           verifier.EndTable();
  }
};

struct GeometryDatabaseBuilder {
  typedef GeometryDatabase Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertex_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertex_buffer) {
    fbb_.AddOffset(GeometryDatabase::VT_VERTEX_BUFFER, vertex_buffer);
  }
  void add_mappings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tempest::Definition::MeshMapping>>> mappings) {
    fbb_.AddOffset(GeometryDatabase::VT_MAPPINGS, mappings);
  }
  explicit GeometryDatabaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryDatabase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDatabase>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDatabase> CreateGeometryDatabase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertex_buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tempest::Definition::MeshMapping>>> mappings = 0) {
  GeometryDatabaseBuilder builder_(_fbb);
  builder_.add_mappings(mappings);
  builder_.add_vertex_buffer(vertex_buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometryDatabase> CreateGeometryDatabaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vertex_buffer = nullptr,
    std::vector<flatbuffers::Offset<Tempest::Definition::MeshMapping>> *mappings = nullptr) {
  auto vertex_buffer__ = vertex_buffer ? _fbb.CreateVector<uint8_t>(*vertex_buffer) : 0;
  auto mappings__ = mappings ? _fbb.CreateVectorOfSortedTables<Tempest::Definition::MeshMapping>(mappings) : 0;
  return Tempest::Definition::CreateGeometryDatabase(
      _fbb,
      vertex_buffer__,
      mappings__);
}

inline const Tempest::Definition::GeometryDatabase *GetGeometryDatabase(const void *buf) {
  return flatbuffers::GetRoot<Tempest::Definition::GeometryDatabase>(buf);
}

inline const Tempest::Definition::GeometryDatabase *GetSizePrefixedGeometryDatabase(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Tempest::Definition::GeometryDatabase>(buf);
}

inline const char *GeometryDatabaseIdentifier() {
  return "TGDB";
}

inline bool GeometryDatabaseBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, GeometryDatabaseIdentifier());
}

inline bool VerifyGeometryDatabaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Tempest::Definition::GeometryDatabase>(GeometryDatabaseIdentifier());
}

inline bool VerifySizePrefixedGeometryDatabaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Tempest::Definition::GeometryDatabase>(GeometryDatabaseIdentifier());
}

inline const char *GeometryDatabaseExtension() {
  return "tgb";
}

inline void FinishGeometryDatabaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tempest::Definition::GeometryDatabase> root) {
  fbb.Finish(root, GeometryDatabaseIdentifier());
}

inline void FinishSizePrefixedGeometryDatabaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tempest::Definition::GeometryDatabase> root) {
  fbb.FinishSizePrefixed(root, GeometryDatabaseIdentifier());
}

}  // namespace Definition
}  // namespace Tempest

#endif  // FLATBUFFERS_GENERATED_GEOMETRYDATABASE_TEMPEST_DEFINITION_H_
