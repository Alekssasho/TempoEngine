// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTUREDATABASE_TEMPEST_DEFINITION_H_
#define FLATBUFFERS_GENERATED_TEXTUREDATABASE_TEMPEST_DEFINITION_H_

#include "flatbuffers/flatbuffers.h"

namespace Tempest {
namespace Definition {

struct TextureData;

struct TextureMapping;

struct TextureDatabase;
struct TextureDatabaseBuilder;

enum TextureFormat {
  TextureFormat_RGBA8 = 0,
  TextureFormat_MIN = TextureFormat_RGBA8,
  TextureFormat_MAX = TextureFormat_RGBA8
};

inline const TextureFormat (&EnumValuesTextureFormat())[1] {
  static const TextureFormat values[] = {
    TextureFormat_RGBA8
  };
  return values;
}

inline const char * const *EnumNamesTextureFormat() {
  static const char * const names[2] = {
    "RGBA8",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  if (flatbuffers::IsOutRange(e, TextureFormat_RGBA8, TextureFormat_RGBA8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFormat()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TextureData FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t width_;
  uint32_t height_;
  int8_t format_;
  int8_t padding0__;  int16_t padding1__;

 public:
  TextureData()
      : width_(0),
        height_(0),
        format_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  TextureData(uint32_t _width, uint32_t _height, Tempest::Definition::TextureFormat _format)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)),
        format_(flatbuffers::EndianScalar(static_cast<int8_t>(_format))),
        padding0__(0),
        padding1__(0) {
  }
  uint32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  uint32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
  Tempest::Definition::TextureFormat format() const {
    return static_cast<Tempest::Definition::TextureFormat>(flatbuffers::EndianScalar(format_));
  }
};
FLATBUFFERS_STRUCT_END(TextureData, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TextureMapping FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t index_;
  uint32_t texture_buffer_offset_;
  uint32_t texture_buffer_byte_count_;
  Tempest::Definition::TextureData texture_data_;

 public:
  TextureMapping()
      : index_(0),
        texture_buffer_offset_(0),
        texture_buffer_byte_count_(0),
        texture_data_() {
  }
  TextureMapping(uint32_t _index, uint32_t _texture_buffer_offset, uint32_t _texture_buffer_byte_count, const Tempest::Definition::TextureData &_texture_data)
      : index_(flatbuffers::EndianScalar(_index)),
        texture_buffer_offset_(flatbuffers::EndianScalar(_texture_buffer_offset)),
        texture_buffer_byte_count_(flatbuffers::EndianScalar(_texture_buffer_byte_count)),
        texture_data_(_texture_data) {
  }
  uint32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  bool KeyCompareLessThan(const TextureMapping *o) const {
    return index() < o->index();
  }
  int KeyCompareWithValue(uint32_t val) const {
    return static_cast<int>(index() > val) - static_cast<int>(index() < val);
  }
  uint32_t texture_buffer_offset() const {
    return flatbuffers::EndianScalar(texture_buffer_offset_);
  }
  uint32_t texture_buffer_byte_count() const {
    return flatbuffers::EndianScalar(texture_buffer_byte_count_);
  }
  const Tempest::Definition::TextureData &texture_data() const {
    return texture_data_;
  }
};
FLATBUFFERS_STRUCT_END(TextureMapping, 24);

struct TextureDatabase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureDatabaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURE_DATA_BUFFER = 4,
    VT_MAPPINGS = 6
  };
  const flatbuffers::Vector<uint8_t> *texture_data_buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TEXTURE_DATA_BUFFER);
  }
  const flatbuffers::Vector<const Tempest::Definition::TextureMapping *> *mappings() const {
    return GetPointer<const flatbuffers::Vector<const Tempest::Definition::TextureMapping *> *>(VT_MAPPINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURE_DATA_BUFFER) &&
           verifier.VerifyVector(texture_data_buffer()) &&
           VerifyOffset(verifier, VT_MAPPINGS) &&
           verifier.VerifyVector(mappings()) &&
           verifier.EndTable();
  }
};

struct TextureDatabaseBuilder {
  typedef TextureDatabase Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texture_data_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> texture_data_buffer) {
    fbb_.AddOffset(TextureDatabase::VT_TEXTURE_DATA_BUFFER, texture_data_buffer);
  }
  void add_mappings(flatbuffers::Offset<flatbuffers::Vector<const Tempest::Definition::TextureMapping *>> mappings) {
    fbb_.AddOffset(TextureDatabase::VT_MAPPINGS, mappings);
  }
  explicit TextureDatabaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureDatabase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureDatabase>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureDatabase> CreateTextureDatabase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> texture_data_buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Tempest::Definition::TextureMapping *>> mappings = 0) {
  TextureDatabaseBuilder builder_(_fbb);
  builder_.add_mappings(mappings);
  builder_.add_texture_data_buffer(texture_data_buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureDatabase> CreateTextureDatabaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *texture_data_buffer = nullptr,
    std::vector<Tempest::Definition::TextureMapping> *mappings = nullptr) {
  auto texture_data_buffer__ = texture_data_buffer ? _fbb.CreateVector<uint8_t>(*texture_data_buffer) : 0;
  auto mappings__ = mappings ? _fbb.CreateVectorOfSortedStructs<Tempest::Definition::TextureMapping>(mappings) : 0;
  return Tempest::Definition::CreateTextureDatabase(
      _fbb,
      texture_data_buffer__,
      mappings__);
}

inline const Tempest::Definition::TextureDatabase *GetTextureDatabase(const void *buf) {
  return flatbuffers::GetRoot<Tempest::Definition::TextureDatabase>(buf);
}

inline const Tempest::Definition::TextureDatabase *GetSizePrefixedTextureDatabase(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Tempest::Definition::TextureDatabase>(buf);
}

inline const char *TextureDatabaseIdentifier() {
  return "TTDB";
}

inline bool TextureDatabaseBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, TextureDatabaseIdentifier());
}

inline bool VerifyTextureDatabaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Tempest::Definition::TextureDatabase>(TextureDatabaseIdentifier());
}

inline bool VerifySizePrefixedTextureDatabaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Tempest::Definition::TextureDatabase>(TextureDatabaseIdentifier());
}

inline const char *TextureDatabaseExtension() {
  return "ttb";
}

inline void FinishTextureDatabaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tempest::Definition::TextureDatabase> root) {
  fbb.Finish(root, TextureDatabaseIdentifier());
}

inline void FinishSizePrefixedTextureDatabaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tempest::Definition::TextureDatabase> root) {
  fbb.FinishSizePrefixed(root, TextureDatabaseIdentifier());
}

}  // namespace Definition
}  // namespace Tempest

#endif  // FLATBUFFERS_GENERATED_TEXTUREDATABASE_TEMPEST_DEFINITION_H_
