// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod common {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    #[allow(unused_imports, dead_code)]
    pub mod tempest {

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;

        #[allow(non_camel_case_types)]
        #[repr(u32)]
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
        pub enum PhysicsShapeFilter {
            NonDrivableSurface = 65535,
            DrivableSurface = 4294901760,
        }

        pub const ENUM_MIN_PHYSICS_SHAPE_FILTER: u32 = 65535;
        pub const ENUM_MAX_PHYSICS_SHAPE_FILTER: u32 = 4294901760;

        impl<'a> flatbuffers::Follow<'a> for PhysicsShapeFilter {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for PhysicsShapeFilter {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = u32::to_le(self as u32);
                let p = &n as *const u32 as *const PhysicsShapeFilter;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = u32::from_le(self as u32);
                let p = &n as *const u32 as *const PhysicsShapeFilter;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for PhysicsShapeFilter {
            type Output = PhysicsShapeFilter;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<PhysicsShapeFilter>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PHYSICS_SHAPE_FILTER: [PhysicsShapeFilter; 2] = [
            PhysicsShapeFilter::NonDrivableSurface,
            PhysicsShapeFilter::DrivableSurface,
        ];

        // struct Vec3, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Vec3 {
            x_: f32,
            y_: f32,
            z_: f32,
        } // pub struct Vec3
        impl flatbuffers::SafeSliceAccess for Vec3 {}
        impl<'a> flatbuffers::Follow<'a> for Vec3 {
            type Inner = &'a Vec3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vec3>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
            type Inner = &'a Vec3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vec3 {
            type Output = Vec3;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Vec3 {
            type Output = Vec3;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Vec3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Vec3 {
            pub fn new<'a>(_x: f32, _y: f32, _z: f32) -> Self {
                Vec3 {
                    x_: _x.to_little_endian(),
                    y_: _y.to_little_endian(),
                    z_: _z.to_little_endian(),
                }
            }
            pub fn x<'a>(&'a self) -> f32 {
                self.x_.from_little_endian()
            }
            pub fn y<'a>(&'a self) -> f32 {
                self.y_.from_little_endian()
            }
            pub fn z<'a>(&'a self) -> f32 {
                self.z_.from_little_endian()
            }
        }

        // struct Color, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Color {
            r_: f32,
            g_: f32,
            b_: f32,
            a_: f32,
        } // pub struct Color
        impl flatbuffers::SafeSliceAccess for Color {}
        impl<'a> flatbuffers::Follow<'a> for Color {
            type Inner = &'a Color;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Color>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Color {
            type Inner = &'a Color;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Color>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Color {
            type Output = Color;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Color as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Color {
            type Output = Color;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Color as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Color {
            pub fn new<'a>(_r: f32, _g: f32, _b: f32, _a: f32) -> Self {
                Color {
                    r_: _r.to_little_endian(),
                    g_: _g.to_little_endian(),
                    b_: _b.to_little_endian(),
                    a_: _a.to_little_endian(),
                }
            }
            pub fn r<'a>(&'a self) -> f32 {
                self.r_.from_little_endian()
            }
            pub fn g<'a>(&'a self) -> f32 {
                self.g_.from_little_endian()
            }
            pub fn b<'a>(&'a self) -> f32 {
                self.b_.from_little_endian()
            }
            pub fn a<'a>(&'a self) -> f32 {
                self.a_.from_little_endian()
            }
        }
    } // pub mod Tempest
} // pub mod Common
