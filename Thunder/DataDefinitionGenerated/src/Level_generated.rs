// automatically generated by the FlatBuffers compiler, do not modify

use crate::CommonTypes_generated::*;
use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod tempest {

    use crate::CommonTypes_generated::*;
    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    #[allow(unused_imports, dead_code)]
    pub mod definition {

        use crate::CommonTypes_generated::*;
        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;

        // struct Camera, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Camera {
            yfov_: f32,
            znear_: f32,
            zfar_: f32,
            aspect_ratio_: f32,
            position_: super::super::common::tempest::Vec3,
            forward_: super::super::common::tempest::Vec3,
            up_: super::super::common::tempest::Vec3,
        } // pub struct Camera
        impl flatbuffers::SafeSliceAccess for Camera {}
        impl<'a> flatbuffers::Follow<'a> for Camera {
            type Inner = &'a Camera;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Camera>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Camera {
            type Inner = &'a Camera;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Camera>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Camera {
            type Output = Camera;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Camera as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Camera {
            type Output = Camera;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Camera as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Camera {
            pub fn new<'a>(
                _yfov: f32,
                _znear: f32,
                _zfar: f32,
                _aspect_ratio: f32,
                _position: &'a super::super::common::tempest::Vec3,
                _forward: &'a super::super::common::tempest::Vec3,
                _up: &'a super::super::common::tempest::Vec3,
            ) -> Self {
                Camera {
                    yfov_: _yfov.to_little_endian(),
                    znear_: _znear.to_little_endian(),
                    zfar_: _zfar.to_little_endian(),
                    aspect_ratio_: _aspect_ratio.to_little_endian(),
                    position_: *_position,
                    forward_: *_forward,
                    up_: *_up,
                }
            }
            pub fn yfov<'a>(&'a self) -> f32 {
                self.yfov_.from_little_endian()
            }
            pub fn znear<'a>(&'a self) -> f32 {
                self.znear_.from_little_endian()
            }
            pub fn zfar<'a>(&'a self) -> f32 {
                self.zfar_.from_little_endian()
            }
            pub fn aspect_ratio<'a>(&'a self) -> f32 {
                self.aspect_ratio_.from_little_endian()
            }
            pub fn position<'a>(&'a self) -> &'a super::super::common::tempest::Vec3 {
                &self.position_
            }
            pub fn forward<'a>(&'a self) -> &'a super::super::common::tempest::Vec3 {
                &self.forward_
            }
            pub fn up<'a>(&'a self) -> &'a super::super::common::tempest::Vec3 {
                &self.up_
            }
        }

        pub enum LevelOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Level<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Level<'a> {
            type Inner = Level<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf: buf, loc: loc },
                }
            }
        }

        impl<'a> Level<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Level { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args LevelArgs<'args>,
            ) -> flatbuffers::WIPOffset<Level<'bldr>> {
                let mut builder = LevelBuilder::new(_fbb);
                if let Some(x) = args.camera {
                    builder.add_camera(x);
                }
                if let Some(x) = args.audio_database_file {
                    builder.add_audio_database_file(x);
                }
                if let Some(x) = args.geometry_database_file {
                    builder.add_geometry_database_file(x);
                }
                if let Some(x) = args.physics_world {
                    builder.add_physics_world(x);
                }
                if let Some(x) = args.entities {
                    builder.add_entities(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_ENTITIES: flatbuffers::VOffsetT = 6;
            pub const VT_PHYSICS_WORLD: flatbuffers::VOffsetT = 8;
            pub const VT_GEOMETRY_DATABASE_FILE: flatbuffers::VOffsetT = 10;
            pub const VT_AUDIO_DATABASE_FILE: flatbuffers::VOffsetT = 12;
            pub const VT_CAMERA: flatbuffers::VOffsetT = 14;

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Level::VT_NAME, None)
            }
            #[inline]
            pub fn entities(&self) -> Option<&'a [u8]> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Level::VT_ENTITIES,
                        None,
                    )
                    .map(|v| v.safe_slice())
            }
            #[inline]
            pub fn physics_world(&self) -> Option<&'a [u8]> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Level::VT_PHYSICS_WORLD,
                        None,
                    )
                    .map(|v| v.safe_slice())
            }
            #[inline]
            pub fn geometry_database_file(&self) -> Option<&'a str> {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    Level::VT_GEOMETRY_DATABASE_FILE,
                    None,
                )
            }
            #[inline]
            pub fn audio_database_file(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Level::VT_AUDIO_DATABASE_FILE, None)
            }
            #[inline]
            pub fn camera(&self) -> Option<&'a Camera> {
                self._tab.get::<Camera>(Level::VT_CAMERA, None)
            }
        }

        pub struct LevelArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub physics_world: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub geometry_database_file: Option<flatbuffers::WIPOffset<&'a str>>,
            pub audio_database_file: Option<flatbuffers::WIPOffset<&'a str>>,
            pub camera: Option<&'a Camera>,
        }
        impl<'a> Default for LevelArgs<'a> {
            #[inline]
            fn default() -> Self {
                LevelArgs {
                    name: None,
                    entities: None,
                    physics_world: None,
                    geometry_database_file: None,
                    audio_database_file: None,
                    camera: None,
                }
            }
        }
        pub struct LevelBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> LevelBuilder<'a, 'b> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Level::VT_NAME, name);
            }
            #[inline]
            pub fn add_entities(
                &mut self,
                entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Level::VT_ENTITIES, entities);
            }
            #[inline]
            pub fn add_physics_world(
                &mut self,
                physics_world: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Level::VT_PHYSICS_WORLD,
                    physics_world,
                );
            }
            #[inline]
            pub fn add_geometry_database_file(
                &mut self,
                geometry_database_file: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Level::VT_GEOMETRY_DATABASE_FILE,
                    geometry_database_file,
                );
            }
            #[inline]
            pub fn add_audio_database_file(
                &mut self,
                audio_database_file: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Level::VT_AUDIO_DATABASE_FILE,
                    audio_database_file,
                );
            }
            #[inline]
            pub fn add_camera(&mut self, camera: &'b Camera) {
                self.fbb_
                    .push_slot_always::<&Camera>(Level::VT_CAMERA, camera);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LevelBuilder<'a, 'b> {
                let start = _fbb.start_table();
                LevelBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Level<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        #[inline]
        pub fn get_root_as_level<'a>(buf: &'a [u8]) -> Level<'a> {
            flatbuffers::get_root::<Level<'a>>(buf)
        }

        #[inline]
        pub fn get_size_prefixed_root_as_level<'a>(buf: &'a [u8]) -> Level<'a> {
            flatbuffers::get_size_prefixed_root::<Level<'a>>(buf)
        }

        pub const LEVEL_IDENTIFIER: &'static str = "TLDB";

        #[inline]
        pub fn level_buffer_has_identifier(buf: &[u8]) -> bool {
            return flatbuffers::buffer_has_identifier(buf, LEVEL_IDENTIFIER, false);
        }

        #[inline]
        pub fn level_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
            return flatbuffers::buffer_has_identifier(buf, LEVEL_IDENTIFIER, true);
        }

        pub const LEVEL_EXTENSION: &'static str = "tlb";

        #[inline]
        pub fn finish_level_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<Level<'a>>,
        ) {
            fbb.finish(root, Some(LEVEL_IDENTIFIER));
        }

        #[inline]
        pub fn finish_size_prefixed_level_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<Level<'a>>,
        ) {
            fbb.finish_size_prefixed(root, Some(LEVEL_IDENTIFIER));
        }
    } // pub mod Definition
} // pub mod Tempest
