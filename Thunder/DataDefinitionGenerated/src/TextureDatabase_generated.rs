// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod tempest {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    #[allow(unused_imports, dead_code)]
    pub mod definition {

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
        pub enum TextureFormat {
            RGBA8 = 0,
        }

        pub const ENUM_MIN_TEXTURE_FORMAT: i8 = 0;
        pub const ENUM_MAX_TEXTURE_FORMAT: i8 = 0;

        impl<'a> flatbuffers::Follow<'a> for TextureFormat {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for TextureFormat {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const TextureFormat;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const TextureFormat;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for TextureFormat {
            type Output = TextureFormat;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<TextureFormat>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TEXTURE_FORMAT: [TextureFormat; 1] = [TextureFormat::RGBA8];

        #[allow(non_camel_case_types)]
        pub const ENUM_NAMES_TEXTURE_FORMAT: [&'static str; 1] = ["RGBA8"];

        pub fn enum_name_texture_format(e: TextureFormat) -> &'static str {
            let index = e as i8;
            ENUM_NAMES_TEXTURE_FORMAT[index as usize]
        }

        // struct TextureData, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct TextureData {
            width_: u32,
            height_: u32,
            format_: TextureFormat,
            padding0__: u8,
            padding1__: u16,
        } // pub struct TextureData
        impl flatbuffers::SafeSliceAccess for TextureData {}
        impl<'a> flatbuffers::Follow<'a> for TextureData {
            type Inner = &'a TextureData;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a TextureData>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a TextureData {
            type Inner = &'a TextureData;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<TextureData>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for TextureData {
            type Output = TextureData;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        self as *const TextureData as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b TextureData {
            type Output = TextureData;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        *self as *const TextureData as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }

        impl TextureData {
            pub fn new<'a>(_width: u32, _height: u32, _format: TextureFormat) -> Self {
                TextureData {
                    width_: _width.to_little_endian(),
                    height_: _height.to_little_endian(),
                    format_: _format.to_little_endian(),

                    padding0__: 0,
                    padding1__: 0,
                }
            }
            pub fn width<'a>(&'a self) -> u32 {
                self.width_.from_little_endian()
            }
            pub fn height<'a>(&'a self) -> u32 {
                self.height_.from_little_endian()
            }
            pub fn format<'a>(&'a self) -> TextureFormat {
                self.format_.from_little_endian()
            }
        }

        // struct TextureMapping, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct TextureMapping {
            index_: u32,
            texture_buffer_offset_: u32,
            texture_buffer_byte_count_: u32,
            texture_data_: TextureData,
        } // pub struct TextureMapping
        impl flatbuffers::SafeSliceAccess for TextureMapping {}
        impl<'a> flatbuffers::Follow<'a> for TextureMapping {
            type Inner = &'a TextureMapping;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a TextureMapping>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a TextureMapping {
            type Inner = &'a TextureMapping;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<TextureMapping>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for TextureMapping {
            type Output = TextureMapping;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        self as *const TextureMapping as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b TextureMapping {
            type Output = TextureMapping;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        *self as *const TextureMapping as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }

        impl TextureMapping {
            pub fn new<'a>(
                _index: u32,
                _texture_buffer_offset: u32,
                _texture_buffer_byte_count: u32,
                _texture_data: &'a TextureData,
            ) -> Self {
                TextureMapping {
                    index_: _index.to_little_endian(),
                    texture_buffer_offset_: _texture_buffer_offset.to_little_endian(),
                    texture_buffer_byte_count_: _texture_buffer_byte_count.to_little_endian(),
                    texture_data_: *_texture_data,
                }
            }
            pub fn index<'a>(&'a self) -> u32 {
                self.index_.from_little_endian()
            }
            #[inline]
            pub fn key_compare_less_than(&self, o: &TextureMapping) -> bool {
                self.index() < o.index()
            }

            #[inline]
            pub fn key_compare_with_value(&self, val: u32) -> ::std::cmp::Ordering {
                let key = self.index();
                key.cmp(&val)
            }
            pub fn texture_buffer_offset<'a>(&'a self) -> u32 {
                self.texture_buffer_offset_.from_little_endian()
            }
            pub fn texture_buffer_byte_count<'a>(&'a self) -> u32 {
                self.texture_buffer_byte_count_.from_little_endian()
            }
            pub fn texture_data<'a>(&'a self) -> &'a TextureData {
                &self.texture_data_
            }
        }

        pub enum TextureDatabaseOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TextureDatabase<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TextureDatabase<'a> {
            type Inner = TextureDatabase<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf: buf, loc: loc },
                }
            }
        }

        impl<'a> TextureDatabase<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TextureDatabase { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TextureDatabaseArgs<'args>,
            ) -> flatbuffers::WIPOffset<TextureDatabase<'bldr>> {
                let mut builder = TextureDatabaseBuilder::new(_fbb);
                if let Some(x) = args.mappings {
                    builder.add_mappings(x);
                }
                if let Some(x) = args.texture_data_buffer {
                    builder.add_texture_data_buffer(x);
                }
                builder.finish()
            }

            pub const VT_TEXTURE_DATA_BUFFER: flatbuffers::VOffsetT = 4;
            pub const VT_MAPPINGS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn texture_data_buffer(&self) -> Option<&'a [u8]> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TextureDatabase::VT_TEXTURE_DATA_BUFFER,
                        None,
                    )
                    .map(|v| v.safe_slice())
            }
            #[inline]
            pub fn mappings(&self) -> Option<&'a [TextureMapping]> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<TextureMapping>>>(
                        TextureDatabase::VT_MAPPINGS,
                        None,
                    )
                    .map(|v| v.safe_slice())
            }
        }

        pub struct TextureDatabaseArgs<'a> {
            pub texture_data_buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub mappings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, TextureMapping>>>,
        }
        impl<'a> Default for TextureDatabaseArgs<'a> {
            #[inline]
            fn default() -> Self {
                TextureDatabaseArgs {
                    texture_data_buffer: None,
                    mappings: None,
                }
            }
        }
        pub struct TextureDatabaseBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TextureDatabaseBuilder<'a, 'b> {
            #[inline]
            pub fn add_texture_data_buffer(
                &mut self,
                texture_data_buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TextureDatabase::VT_TEXTURE_DATA_BUFFER,
                    texture_data_buffer,
                );
            }
            #[inline]
            pub fn add_mappings(
                &mut self,
                mappings: flatbuffers::WIPOffset<flatbuffers::Vector<'b, TextureMapping>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TextureDatabase::VT_MAPPINGS,
                    mappings,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TextureDatabaseBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TextureDatabaseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TextureDatabase<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        #[inline]
        pub fn get_root_as_texture_database<'a>(buf: &'a [u8]) -> TextureDatabase<'a> {
            flatbuffers::get_root::<TextureDatabase<'a>>(buf)
        }

        #[inline]
        pub fn get_size_prefixed_root_as_texture_database<'a>(
            buf: &'a [u8],
        ) -> TextureDatabase<'a> {
            flatbuffers::get_size_prefixed_root::<TextureDatabase<'a>>(buf)
        }

        pub const TEXTURE_DATABASE_IDENTIFIER: &'static str = "TTDB";

        #[inline]
        pub fn texture_database_buffer_has_identifier(buf: &[u8]) -> bool {
            return flatbuffers::buffer_has_identifier(buf, TEXTURE_DATABASE_IDENTIFIER, false);
        }

        #[inline]
        pub fn texture_database_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
            return flatbuffers::buffer_has_identifier(buf, TEXTURE_DATABASE_IDENTIFIER, true);
        }

        pub const TEXTURE_DATABASE_EXTENSION: &'static str = "ttb";

        #[inline]
        pub fn finish_texture_database_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TextureDatabase<'a>>,
        ) {
            fbb.finish(root, Some(TEXTURE_DATABASE_IDENTIFIER));
        }

        #[inline]
        pub fn finish_size_prefixed_texture_database_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TextureDatabase<'a>>,
        ) {
            fbb.finish_size_prefixed(root, Some(TEXTURE_DATABASE_IDENTIFIER));
        }
    } // pub mod Definition
} // pub mod Tempest
